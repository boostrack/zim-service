import org.gradle.api.*
import org.gradle.api.tasks.*

buildscript {
    repositories {
        mavenCentral()
        maven { url "http://repo.spring.io/libs-snapshot" }
    }
    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:1.0.0.RC3"
    }
}

apply plugin: 'spring-boot'
apply plugin: 'groovy'

repositories {
    maven {
        mavenCentral()
        url 'http://repo.spring.io/milestone'
    }
}

dependencies {
    compile "org.codehaus.groovy:groovy:2.2.2"
    compile "org.springframework.boot:spring-boot-starter-web:1.0.0.RC4"
    compile "org.springframework.data:spring-data-commons:1.6.2.RELEASE"
    compile "org.springframework.data:spring-data-mongodb:1.4.0.RELEASE"
    runtime "org.mongodb:mongo-java-driver:2.9.1"
    testCompile 'junit:junit:4.11'
    testCompile 'info.cukes:cucumber-junit:1.1.5'
    testCompile 'info.cukes:cucumber-groovy:1.1.5'
    testCompile 'com.github.groovy-wslite:groovy-wslite:0.8.0'
    //testCompile "de.flapdoodle.embed:de.flapdoodle.embed.mongo:1.41"
}

test.testLogging.exceptionFormat = 'full'

configurations {
    functTestCompile.extendsFrom testCompile
    functTestRuntime.extendsFrom testRuntime
}

ext {
    functionalJettyHttpPort = 8037
    functionalJettyStopPort = 9937
    functionalJettyStopKey = 'stopKey'
}

sourceSets {
    functionalTest {
        groovy.srcDir file('src/testFunctional/groovy')
        resources.srcDir     file('src/testFunctional/resources')
        compileClasspath = sourceSets.main.output + sourceSets.test.output + configurations.functTestCompile
        runtimeClasspath = output + compileClasspath + configurations.functTestRuntime
    }
}

task startServer(type: ExecWait, dependsOn: 'assemble') {
    command 'java -jar build/libs/zim-service.jar'
    ready 'Started Application'
    directory '.'
}

task stopServer(type: ExecKill)

task functionalTest(type: Test) {
    testClassesDir = sourceSets.functionalTest.output.classesDir
    classpath = sourceSets.functionalTest.runtimeClasspath
    dependsOn startServer
    finalizedBy stopServer
}

check.dependsOn functionalTest

class ExecWait extends DefaultTask {
    String command
    String ready
    String directory

    @TaskAction
    def spawnProcess() {

        def pidFile = new File('.gradle-exec-wait.pid')
        if(pidFile.exists()) throw new GradleException("Server already running!")

        def builder = new ProcessBuilder(command.split(' '))
        builder.redirectErrorStream(true)
        builder.directory(new File(directory))
        def process = builder.start()

        def f = process.class.getDeclaredField("pid")
        f.accessible = true
        def pid = f.getInt(process)
        pidFile << pid

        def line
        def reader = new BufferedReader(new InputStreamReader(process.getInputStream()))
        while ((line = reader.readLine()) != null) {
            println line
            if (line.contains(ready)) {
                println "$command is ready"
                break;
            }
        }
    }
}

class ExecKill extends DefaultTask {
    @TaskAction
    def killProcess(){
        def pidFile = new File('.gradle-exec-wait.pid')
        if(!pidFile.exists()) throw new GradleException("No server running!")

        def pid = pidFile.text
        def cmd = "kill $pid"
        def process = cmd.execute()
        process.waitFor()
        pidFile.delete()
    }
}
